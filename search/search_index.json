{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuickGrpc","text":"<p>This is a simple framework to help your kickstart your grpc service development in python, and to publish the same for someone to invoke...</p> <p>Welcome to an easy-to-use framework designed to accelerate your development of gRPC services in Python, along with seamless publishing for others to invoke. This framework offers a streamlined approach, allowing you to focus on building robust and efficient gRPC services without getting bogged down in intricate details.</p> <p>With clear and concise documentation, this framework simplifies the process of creating and publishing gRPC services, making it accessible for developers of all levels. Whether you're a seasoned expert or just starting out with gRPC, our framework provides the necessary tools and guidance to get you up and running quickly.</p> <p>By leveraging this framework, you can harness the power of gRPC to create high-performance, scalable services, enabling seamless communication between distributed systems. Whether you're building microservices, client-server applications, or distributed systems, our framework empowers you to deliver reliable and efficient solutions with ease.</p> <p>So, dive in and unleash the potential of gRPC with our comprehensive framework, designed to streamline your development process and accelerate your journey towards building robust and scalable services.</p>"},{"location":"Get%20Started/","title":"QuickGrpc-py","text":"<p>This is a simple framework to help your kickstart your grpc service development in python, and to publish the same for someone to invoke...</p> <p>Let's go</p> <p>Here's the proto file</p> <pre><code>syntax = \"proto3\";\n\nservice Greet{\n    rpc hi(Inp) returns (Out);\n    rpc bye(Inp) returns (Out);\n}\n\nmessage Inp{\n  string name = 1;\n}\n\nmessage Out{\n  string text = 1;\n}\n</code></pre> <p>Here's what a day to day workflow should look like.</p> <pre><code>~/Desktop via py v3.11.6 (base)\n&gt; tree\n.\n\u2514\u2500\u2500 rpc\n    \u2514\u2500\u2500 greet.proto\n\n2 directories, 1 file\n\n~/Desktop via py v3.11.6 (base)\n&gt; cd rpc/\n\n~/Desktop/rpc via py v3.11.6 (base)\n&gt; create_grpc_service -f greet.proto -c yes\npath: greet.proto\npb_path: /home/ashu/venvs/base/lib/python3.11/site-packages/grpc_assets/greet\nGenerating Server Code...\nParsing protobuf...\nParsed protobuf: [\n  {\n    \"name\": \"Greet\",\n    \"methods\": [\n      \"hi\",\n      \"bye\"\n    ]\n  }\n]\nAdding service: Greet\nAdding method: hi\nAdding method: bye\nGenerating Client Code...\nParsing protobuf...\nParsed protobuf: [\n  {\n    \"name\": \"Greet\",\n    \"methods\": [\n      \"hi\",\n      \"bye\"\n    ]\n  }\n]\nAdding service: Greet\nAdding method: hi\nAdding method: bye\n</code></pre> <p>This generates, two things... one service class and a test case, like so...</p> <pre><code>~/Desktop via py v3.11.6 (base)\n&gt; tree rpc/\nrpc/\n\u251c\u2500\u2500 greet.proto\n\u251c\u2500\u2500 greet.py\n\u2514\u2500\u2500 tests\n    \u2514\u2500\u2500 test_greet.py\n\n2 directories, 3 files\n</code></pre> <p>service</p> <pre><code>from grpc_assets.greet import greet_pb2\nfrom grpc_assets.greet.greet_pb2_grpc import GreetServicer\n\n\"\"\"\nProto\nsyntax = \"proto3\";\n\nservice Greet{\n    rpc hi(Inp) returns (Out);\n    rpc bye(Inp) returns (Out);\n}\n\nmessage Inp{\n  string name = 1;\n}\n\nmessage Out{\n  string text = 1;\n}\n\n\"\"\"\n\n\nclass GreetService(GreetServicer):\n    def hi(self, context):\n        \"\"\"\n        # TODO: add inputs as per proto\n        # TODO: add logic and return output as per proto\n        \"\"\"\n        return\n\n    def bye(self, context):\n        \"\"\"\n        # TODO: add inputs as per proto\n        # TODO: add logic and return output as per proto\n        \"\"\"\n        return\n</code></pre> <p>testcase </p> <pre><code>from grpc_assets.stub import get_stub\nimport grpc_assets.greet.greet_pb2 as pb2\nfrom unittest import TestCase\n\n\n\"\"\"\nProto\nsyntax = \"proto3\";\n\nservice Greet{\n    rpc hi(Inp) returns (Out);\n    rpc bye(Inp) returns (Out);\n}\n\nmessage Inp{\n  string name = 1;\n}\n\nmessage Out{\n  string text = 1;\n}\n\n\"\"\"\n\n\nclass GreetClientTestCase(TestCase):\n    stub = get_stub(\"greet\")\n\n    def test_hi(self):\n        # stub.&lt;your rpc method&gt;(pb2.&lt;your proto message&gt;(params))\n        ...\n\n    def test_bye(self):\n        # stub.&lt;your rpc method&gt;(pb2.&lt;your proto message&gt;(params))\n        ...\n</code></pre> <p>Then all I have to do is implement the methods...</p> <p>Service </p> <pre><code>class GreetService(GreetServicer):\n    def hi(self, inp, context):\n        print(f\"req: {inp}\")\n        return greet_pb2.Out(text=f\"Hi {inp.name}\")\n\n    def bye(self, inp, context):\n        print(f\"req: {inp}\")\n        return greet_pb2.Out(text=f\"Bye {inp.name}\")\n</code></pre> <p>Testcase</p> <pre><code>class GreetClientTestCase(TestCase):\n    stub = get_stub(\"greet\")\n\n    def test_hi(self):\n        print(self.stub.hi(pb2.Inp(name=\"Ashu\")))\n\n    def test_bye(self):\n        print(self.stub.bye(pb2.Inp(name=\"Ashu\")))\n</code></pre> <p>That's it, then I should be able to call the service like so...</p> <p>server </p> <pre><code>~/Desktop via py v3.11.6 (base)\nx export GRPC_PORT=50001\n\n~/Desktop via py v3.11.6 (base)\n&gt; servegrpc\n/home/ashu/venvs/base/bin/servegrpc:21: PydanticDeprecatedSince20: `pydantic.config.Extra` is deprecated, use literal values instead (e.g. `extra='allow'`). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.3/migration/\n  extra = Extra.ignore\nstarting grpc server...\nreq: name: \"Ashu\"\n\nreq: name: \"Ashu\"\n</code></pre> <p>client</p> <pre><code>&gt; python3 -m unittest rpc.tests.test_greet\ntext: \"Bye Ashu\"\n\n.text: \"Hi Ashu\"\n\n.\n----------------------------------------------------------------------\nRan 2 tests in 0.006s\n\nOK\n</code></pre> <p>Note, here, I'm storing the protoc generated pb2 files under a package called grpc_assets under site-packages. Also,  there's one catch, the code gen logic I wrote has one retriction, proto file name needs to match the main service name, which limits the number of services to 1. </p> <p>This can always be improved upon.</p>"},{"location":"Installation/","title":"QuickgRPC 0.1.0 Installation Guide","text":"<p>QuickgRPC is a lightweight Python library for quickly setting up gRPC (Google Remote Procedure Call) servers and clients. This guide will walk you through the installation process for QuickgRPC version 0.1.0.</p>"},{"location":"Installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.6 or higher</li> <li>pip (Python package manager)</li> </ul>"},{"location":"Installation/#installation-steps","title":"Installation Steps","text":"<ol> <li> <p>Install QuickgRPC: You can install QuickgRPC using pip. Open your terminal or command prompt and execute the following command:</p> <p><code>pip install quickgrpc</code></p> </li> <li> <p>Verify Installation: Once the installation is complete, you can verify that QuickgRPC is installed correctly by checking the version:</p> <p><code>python -c \"import quickgrpc; print(quickgrpc.__version__)\"</code></p> <p>If the installation was successful, you should see the version number of QuickgRPC printed in the terminal.</p> </li> <li> <p>Usage: Now that QuickgRPC is installed, you can start using it in your Python projects. Refer to the QuickgRPC documentation and examples for guidance on how to set up gRPC servers and clients using QuickgRPC.</p> </li> </ol>"},{"location":"Installation/#resources","title":"Resources","text":"<ul> <li>QuickgRPC Documentation</li> <li>gRPC Documentation</li> </ul> <p>That's it! You have successfully installed QuickgRPC 0.1.0 on your system. Happy coding!</p>"}]}